# maconfig v1.0 — MVP 核心跑通

## 目标

最小可用版本，能存、能取、能热更新。验收标准：启动 server + demo，通过 POST 写入配置，5 秒内 demo 的 `/demo` 接口返回新值。

---

## 项目结构

```
maconfig/
├── maconfig-server      # 配置服务端，Spring Boot 3.x + MyBatis + H2
├── maconfig-client      # 客户端 SDK，纯 Spring Context，无 Boot 依赖
└── maconfig-demo        # 演示应用，接入 client SDK 验证热更新
```

---

## 架构设计

### 整体流程

```
┌─────────────────────────────────────────────────────────┐
│                     maconfig-server                      │
│                                                          │
│  POST /v1/configs  ──►  ConfigsService.saveConfigs()    │
│                              │                           │
│                         ConfigsMapper (MyBatis)          │
│                              │                           │
│                          H2 / MySQL                      │
│                              │                           │
│                         VersionHolder (内存)             │
│                              │                           │
│  GET /v1/version   ◄──  返回 currentTimeMillis          │
└─────────────────────────────────────────────────────────┘
                              ▲  HTTP 轮询（每 5 秒）
                              │
┌─────────────────────────────────────────────────────────┐
│                     maconfig-client                      │
│                                                          │
│  MaConfigServiceImpl                                     │
│    ├── 启动时拉取全量配置 → configMap                    │
│    ├── 定时轮询 /v1/version                              │
│    │     版本变化 → 拉取全量 → calcChangedKeys           │
│    │                        → publishEvent               │
│    │                                                     │
│  MaPropertySource (EnumerablePropertySource)             │
│    └── 桥接 Spring Environment，优先级最高               │
│                                                          │
│  SpringValueProcessor (BeanPostProcessor)                │
│    ├── 启动时扫描所有 @Value 字段，建立 key → field 映射 │
│    └── 收到 EnvironmentChangeEvent → 反射写回新值        │
└─────────────────────────────────────────────────────────┘
```

### 配置四元组

每条配置由 `app + env + ns + pkey` 唯一确定，对应数据库主键。客户端按 `app/env/ns` 维度拉取整个命名空间的配置。

### 版本号机制

版本号存在 server 内存的 `ConcurrentHashMap` 中，key 为 `app:env:ns`，每次写入配置时更新为 `System.currentTimeMillis()`。客户端每 5 秒轮询一次版本号，发现变化才拉取全量配置，避免无效传输。

### 分布式锁（主备选举）

基于 MySQL `SELECT ... FOR UPDATE` 行锁实现。抢到锁的实例标记为 Master，持锁期间不提交事务（锁不释放）。其他实例抢锁失败则为 Standby。Master 宕机后连接断开，锁自动释放，Standby 在下一个 5 秒周期内抢到锁晋升为 Master。

---

## 核心模块实现

### maconfig-server

| 类 | 职责 |
|----|------|
| `ConfigEntry` | 数据模型，对应 configs 表五个字段 |
| `ConfigsMapper` | MyBatis 注解 Mapper，实现 findAll / upsert / delete |
| `VersionHolder` | 内存版本号管理，ConcurrentHashMap 保证线程安全 |
| `ConfigsService` | 业务层，组合 Mapper 和 VersionHolder |
| `ConfigsController` | REST 接口，GET/POST /v1/configs，GET /v1/version |
| `DistributedLocks` | 分布式锁，SELECT FOR UPDATE，定时抢锁 |
| `StatusController` | GET /v1/status，返回当前实例是否为 Master |
| `Result<T>` | 统一响应体，code / message / data |

**数据库（H2，开发模式）**

```sql
CREATE TABLE configs (
    app   VARCHAR(64)  NOT NULL,
    env   VARCHAR(64)  NOT NULL,
    ns    VARCHAR(64)  NOT NULL,
    pkey  VARCHAR(128) NOT NULL,
    pval  TEXT,
    PRIMARY KEY (app, env, ns, pkey)
);

CREATE TABLE locks (
    id  INT PRIMARY KEY,
    app VARCHAR(64) NOT NULL
);
INSERT INTO locks VALUES (1, 'maconfig-server');
```

**upsert 语法（H2 兼容）**

```sql
MERGE INTO configs (app, env, ns, pkey, pval)
KEY(app, env, ns, pkey)
VALUES(#{app}, #{env}, #{ns}, #{pkey}, #{pval})
```

### maconfig-client

| 类 | 职责 |
|----|------|
| `ConfigMeta` | 封装 app / env / ns / serverUrl |
| `@EnableMaConfig` | 入口注解，触发 `@Import(MaConfigRegistrar.class)` |
| `MaConfigRegistrar` | `ImportBeanDefinitionRegistrar`，注册 ConfigMeta / MaConfigServiceImpl / PropertySourcesProcessor / SpringValueProcessor |
| `MaConfigServiceImpl` | 核心服务，启动拉取配置，定时轮询版本，发布变更事件 |
| `HttpMaRepository` | 用 JDK `HttpClient` 调用 server HTTP 接口 |
| `MaPropertySource` | 继承 `EnumerablePropertySource`，将 configMap 桥接到 Spring Environment |
| `PropertySourcesProcessor` | `BeanFactoryPostProcessor`，以最高优先级将 MaPropertySource 注入 Environment |
| `SpringValueProcessor` | `BeanPostProcessor` + `ApplicationListener`，扫描 @Value 字段并在变更时反射更新 |
| `PlaceholderHelper` | 解析 `${key:default}` 占位符，提取实际 key |
| `SpringValue` | 持有 bean 实例、Field 引用、占位符原文 |

**启动时序**

```
Spring 容器启动
  │
  ├─ MaConfigRegistrar.registerBeanDefinitions()
  │    注册 ConfigMeta / MaConfigServiceImpl / 两个 Processor
  │
  ├─ PropertySourcesProcessor.postProcessBeanFactory()
  │    MaConfigServiceImpl.afterPropertiesSet() 已执行（InitializingBean）
  │    → 拉取初始配置，填充 configMap
  │    → 将 MaPropertySource 插入 Environment 最高优先级
  │
  ├─ SpringValueProcessor.postProcessBeforeInitialization()
  │    扫描每个 Bean 的 @Value 字段，建立 key → SpringValue 映射
  │
  └─ 应用就绪，后台轮询线程每 5 秒检查版本
       版本变化 → 拉取全量 → EnvironmentChangeEvent
                → SpringValueProcessor.onApplicationEvent()
                → 反射更新 @Value 字段
```

### maconfig-demo

```java
@SpringBootApplication
@EnableMaConfig(app = "demo-app", env = "dev", ns = "default",
                serverUrl = "http://localhost:9091")
public class DemoApplication { ... }

@RestController
public class DemoController {
    @Value("${demo.message:Hello World}")
    private String message;

    @Value("${demo.version:1.0}")
    private String version;

    @GetMapping("/demo")
    public Map<String, String> demo() {
        return Map.of("message", message, "version", version);
    }
}
```

---

## 测试流程

### 环境准备

```bash
# 编译整个项目
./mvnw clean package -DskipTests

# 注意：如果端口 9090 被其他应用（如 ClashX）占用，请修改 server 端口
# 检查端口占用：lsof -i :9090

# 启动 server（默认端口 9091，避免与 ClashX 冲突）
java -jar maconfig-server/target/maconfig-server-*.jar

# 启动 demo（端口 8080）
cd maconfig-demo && ../mvnw spring-boot:run
```

### 步骤一：验证初始状态

```bash
# demo 返回本地默认值
curl http://localhost:8080/demo
# 期望：{"message":"Hello World (local default)","version":"1.0-local"}

# server 当前无配置
curl "http://localhost:9091/v1/configs?app=demo-app&env=dev&ns=default"
# 期望：{"code":200,"message":"ok","data":{}}
```

### 步骤二：写入配置

```bash
curl -X POST "http://localhost:9091/v1/configs?app=demo-app&env=dev&ns=default" \
  -H "Content-Type: application/json" \
  -d '{"demo.message":"Hello from maconfig!","demo.version":"2.0"}'
# 期望：{"code":200,"message":"ok","data":null}
```

### 步骤三：验证热更新（等待 ≤5 秒）

```bash
curl http://localhost:8080/demo
# 期望：{"message":"Hello from maconfig!","version":"2.0"}
```

### 步骤四：验证主备选举

```bash
# 启动第二个 server 实例（端口 9092）
java -jar maconfig-server/target/maconfig-server-*.jar --server.port=9092

# 查看两个实例状态
curl http://localhost:9091/v1/status   # {"code":200,"message":"ok","data":true}
curl http://localhost:9092/v1/status   # {"code":200,"message":"ok","data":true}

# 停掉 9091：kill $(lsof -ti:9091)
# 等待 5 秒后检查 9092 状态
curl http://localhost:9092/v1/status   # {"code":200,"message":"ok","data":true}
```

### 步骤五：H2 控制台（可选）

浏览器访问 `http://localhost:9091/h2-console`，JDBC URL 填 `jdbc:h2:mem:maconfig`，可直接查看 configs / locks 表数据。

> ⚠️ 注意：如果遇到端口冲突，建议先检查 `lsof -i :9090` 确认是否有其他应用占用端口。推荐使用 9091 端口避免冲突。

---

## 已知限制（v2.0 修复）

| 问题 | 影响 | v2.0 方案 |
|------|------|-----------|
| 版本号存内存 | server 重启后版本归零，客户端误判无变化 | 持久化到 `updated_at` 字段，查 `MAX(updated_at)` |
| 无启动容错 | server 不可用时 demo 启动报错 | `fail-fast=false`，降级使用本地默认值 |
| 无配置删除 | 只能写入，无法删除单个 key | 新增 `DELETE /v1/configs` 接口 |
| 端口冲突 | ClashX 等代理软件占用 9090 端口 | 默认使用 9091 端口，文档明确说明端口检查方法和替代方案 |
